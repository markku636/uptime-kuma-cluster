user root;
worker_processes auto;
worker_rlimit_nofile 65535;
error_log /usr/local/openresty/nginx/logs/error.log info;
pid /var/run/nginx.pid;

# å¥åº·æª¢æŸ¥å°ˆç”¨æ—¥èªŒï¼ˆè¨˜éŒ„ info ä»¥ä¸Šï¼‰
error_log /usr/local/openresty/nginx/logs/health-check.log info;


events {
    use epoll;
    worker_connections 65535;
    multi_accept on;
}

http {
    include /usr/local/openresty/nginx/conf/mime.types;
    default_type application/octet-stream;

    # Docker å…§å»º DNS è§£æå™¨ï¼Œä¾› Lua cosocket (å¦‚ resty.mysql) è§£æä¸»æ©Ÿåä½¿ç”¨
    resolver 127.0.0.11 ipv6=off valid=30s;
    resolver_timeout 5s;

    # Map for Connection header handling
    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }

    # æ—¥èªŒæ ¼å¼
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';

    # èª¿è©¦æ—¥èªŒæ ¼å¼
    log_format debug '$remote_addr - $remote_user [$time_local] "$request" '
                     '$status $body_bytes_sent "$http_referer" '
                     '"$http_user_agent" "$http_x_forwarded_for" '
                     'debug_info: "$http_x_debug_info"';

    access_log /usr/local/openresty/nginx/logs/access.log main;
    
    # å¦‚æœå•Ÿç”¨èª¿è©¦æ¨¡å¼ï¼Œæ·»åŠ èª¿è©¦æ—¥èªŒ
    access_log /usr/local/openresty/nginx/logs/debug.log debug;

    # åŸºæœ¬è¨­å®š
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    client_max_body_size 100M;

    # Gzip å£“ç¸®
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript application/javascript application/xml+rss application/json;

    # å…±äº«è¨˜æ†¶é«”å€åŸŸ - å¥åº·æª¢æŸ¥å™¨
    lua_shared_dict health_checker 10m;

    # ä¸Šæ¸¸ä¼ºæœå™¨é…ç½®
    upstream uptime_kuma_backend {
        zone uptime_kuma_backend 64k;
        # ä½¿ç”¨ ip_hash ç¢ºä¿ WebSocket é€£æ¥çš„æœƒè©±ä¸€è‡´æ€§
        ip_hash;
        
        # å‹•æ…‹ç¯€é»é…ç½®ï¼ˆä¾æ“š docker-compose-cluster.yamlï¼‰
        # æ³¨æ„ï¼šupstream server è¡Œä¸æ”¯æ´ resolve åƒæ•¸ï¼Œæ”¹ç”±ä¸Šæ–¹ resolver èˆ‡å®šæ™‚é‡è¼‰/å¥åº·æª¢æŸ¥è™•ç†è§£æ
        server uptime-kuma-node1:3001 max_fails=3 fail_timeout=30s;
        server uptime-kuma-node2:3001 max_fails=3 fail_timeout=30s;
        server uptime-kuma-node3:3001 max_fails=3 fail_timeout=30s;
        
        # å¥åº·æª¢æŸ¥
        keepalive 32;
    }

    # åˆå§‹åŒ–è…³æœ¬ - å…¨å±€åˆå§‹åŒ–ï¼ˆåªåŸ·è¡Œ1æ¬¡ï¼‰
    init_by_lua_block {
        require "resty.core"
        
        -- æª¢æŸ¥èª¿è©¦æ¨¡å¼
        local debug_enabled = os.getenv("EMMY_DEBUG_ENABLED") == "true"
        if debug_enabled then
            ngx.log(ngx.NOTICE, "ğŸ”§ èª¿è©¦æ¨¡å¼å·²å•Ÿç”¨")
        end
        
        -- åˆå§‹åŒ–å¥åº·æª¢æŸ¥å™¨
        local health_check = require "health_check"
        local success = health_check.init()
        if success then
            ngx.log(ngx.INFO, "Health checker initialized successfully")
        else
            ngx.log(ngx.ERR, "Failed to initialize health checker")
        end
    }
    
    # å®šæœŸå¥åº·æª¢æŸ¥ - æ¯å€‹ worker åŸ·è¡Œåˆå§‹åŒ–
    init_worker_by_lua_block {
        local health_check = require "health_check"
        
        -- å•Ÿå‹•å¥åº·æª¢æŸ¥å·¥ä½œå™¨
        local function start_health_check()
            ngx.log(ngx.INFO, "Starting health check worker")
            health_check.health_check_worker()
        end
        
        -- å•Ÿå‹•èª¿è©¦å™¨ï¼ˆå¦‚æœå•Ÿç”¨ï¼‰
        local function start_debugger()
            local debug_enabled = os.getenv("EMMY_DEBUG_ENABLED") == "true"
            if debug_enabled then
                ngx.log(ngx.INFO, "ğŸ”§ æº–å‚™å•Ÿå‹•èª¿è©¦å™¨...")
                -- å»¶é²å•Ÿå‹•èª¿è©¦å™¨ï¼Œç­‰å¾…æœå‹™å®Œå…¨åˆå§‹åŒ–
                ngx.timer.at(5, function()
                    health_check.start_debugger()
                end)
            end
        end
        
        -- å»¶é²å•Ÿå‹•ï¼Œç­‰å¾…æ‰€æœ‰æœå‹™å°±ç·’
        ngx.timer.at(10, start_health_check)
        ngx.timer.at(15, start_debugger)
        
        ngx.log(ngx.INFO, "Health check worker and debugger scheduled")
    }

    # ä¸»è¦æœå‹™é…ç½®
    server {
        listen 80;
        server_name _;
        
        # å®‰å…¨æ¨™é ­
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;

        # å¥åº·æª¢æŸ¥ç«¯é»
        location /health {
            access_log off;
            return 200 '{"status":"healthy","timestamp":"$time_iso8601","service":"nginx-openresty"}';
            add_header Content-Type application/json;
        }

        # å¥åº·æª¢æŸ¥ç‹€æ…‹ API
        location /api/health-status {
            content_by_lua_block {
                local health_check = require "health_check"
                local stats = health_check.get_statistics()
                
                ngx.header.content_type = "application/json"
                ngx.say(require('cjson').encode(stats))
            }
        }

        # æ‰‹å‹•è§¸ç™¼å¥åº·æª¢æŸ¥ API
        location /api/trigger-health-check {
            content_by_lua_block {
                local health_check = require "health_check"
                local success = health_check.run_health_check()
                
                if success then
                    ngx.status = 200
                    ngx.say('{"status":"success","message":"Health check triggered successfully","timestamp":"' .. os.date("%Y-%m-%d %H:%M:%S") .. '"}')
                else
                    ngx.status = 500
                    ngx.say('{"status":"error","message":"Health check failed","timestamp":"' .. os.date("%Y-%m-%d %H:%M:%S") .. '"}')
                end
                
                ngx.header.content_type = "application/json"
            }
        }

        # èª¿è©¦é…ç½® API
        location /api/debug-config {
            content_by_lua_block {
                local health_check = require "health_check"
                local debug_config = health_check.get_debug_config()
                
                ngx.header.content_type = "application/json"
                ngx.say(require('cjson').encode(debug_config))
            }
        }

        # æ‰‹å‹•å•Ÿå‹•èª¿è©¦å™¨ API
        location /api/start-debugger {
            content_by_lua_block {
                local health_check = require "health_check"
                local success = health_check.start_debugger()
                
                if success then
                    ngx.status = 200
                    ngx.say('{"status":"success","message":"Debugger started successfully","timestamp":"' .. os.date("%Y-%m-%d %H:%M:%S") .. '"}')
                else
                    ngx.status = 500
                    ngx.say('{"status":"error","message":"Failed to start debugger","timestamp":"' .. os.date("%Y-%m-%d %H:%M:%S") .. '"}')
                end
                
                ngx.header.content_type = "application/json"
            }
        }

        # èª¿è©¦æ—¥èªŒ API
        location /api/debug-logs {
            content_by_lua_block {
                local debug_enabled = os.getenv("EMMY_DEBUG_ENABLED") == "true"
                
                if not debug_enabled then
                    ngx.status = 400
                    ngx.say('{"status":"error","message":"Debug mode is not enabled"}')
                    ngx.header.content_type = "application/json"
                    return
                end
                
                -- è®€å–èª¿è©¦æ—¥èªŒæª”æ¡ˆ
                local file = io.open("/usr/local/openresty/nginx/logs/debug.log", "r")
                if not file then
                    ngx.status = 404
                    ngx.say('{"status":"error","message":"Debug log file not found"}')
                    ngx.header.content_type = "application/json"
                    return
                end
                
                local content = file:read("*all")
                file:close()
                
                ngx.header.content_type = "text/plain"
                ngx.say(content)
            }
        }

        # éœæ…‹æª”æ¡ˆå¿«å–
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
            proxy_pass http://uptime_kuma_backend;
        }

        # WebSocket å°ˆç”¨è·¯ç”±
        location /socket.io/ {
            proxy_pass http://uptime_kuma_backend;
            
            # åŸºæœ¬ä»£ç†æ¨™é ­
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # WebSocket å‡ç´šæ”¯æ´
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            
            # WebSocket å°ˆç”¨è¶…æ™‚è¨­å®š
            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
            
            # ç¦ç”¨æ‰€æœ‰ç·©è¡å’Œå¿«å–
            proxy_buffering off;
            proxy_cache off;
            proxy_request_buffering off;
            
            # æ•…éšœè™•ç†
            proxy_next_upstream error timeout http_500 http_502 http_503 http_504;
            proxy_next_upstream_tries 2;
            proxy_next_upstream_timeout 5s;
        }

        # ä¸»è¦ WebSocket ç«¯é»
        location /socket {
            proxy_pass http://uptime_kuma_backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # WebSocket æ”¯æ´
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
            
            # è¶…æ™‚è¨­å®š
            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
            
            # ç·©è¡è¨­å®š
            proxy_buffering on;
            proxy_buffer_size 4k;
            proxy_buffers 8 4k;
            
            # æ•…éšœè™•ç†
            proxy_next_upstream error timeout http_500 http_502 http_503 http_504;
            proxy_next_upstream_tries 3;
            proxy_next_upstream_timeout 10s;
        }

        # API å’Œä¸»è¦è«‹æ±‚
        location / {
            proxy_pass http://uptime_kuma_backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # HTTP è«‹æ±‚çš„ WebSocket æ”¯æ´
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
            
            # è¶…æ™‚è¨­å®š
            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
            
            # ç·©è¡è¨­å®š
            proxy_buffering on;
            proxy_buffer_size 4k;
            proxy_buffers 8 4k;
            
            # æ•…éšœè™•ç†
            proxy_next_upstream error timeout http_500 http_502 http_503 http_504;
            proxy_next_upstream_tries 3;
            proxy_next_upstream_timeout 10s;
        }
    }
}
