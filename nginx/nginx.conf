user root;
worker_processes auto;
worker_rlimit_nofile 65535;
error_log /usr/local/openresty/nginx/logs/error.log info;
pid /var/run/nginx.pid;

# å¥åº·æª¢æŸ¥å°ˆç”¨æ—¥èªŒï¼ˆè¨˜éŒ„ info ä»¥ä¸Šï¼‰
error_log /usr/local/openresty/nginx/logs/health-check.log info;


events {
    use epoll;
    worker_connections 65535;
    multi_accept on;
}

http {
    include /usr/local/openresty/nginx/conf/mime.types;
    default_type application/octet-stream;

    # Docker å…§å»º DNS è§£æå™¨
    resolver 127.0.0.11 ipv6=off valid=30s;
    resolver_timeout 5s;

    # Map for Connection header handling
    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }

    # æ—¥èªŒæ ¼å¼
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for" '
                    'upstream: $upstream_addr routed_to: $upstream_http_x_routed_node';

    # èª¿è©¦æ—¥èªŒæ ¼å¼
    log_format debug '$remote_addr - $remote_user [$time_local] "$request" '
                     '$status $body_bytes_sent "$http_referer" '
                     '"$http_user_agent" "$http_x_forwarded_for" '
                     'debug_info: "$http_x_debug_info"';

    access_log /usr/local/openresty/nginx/logs/access.log main;
    
    # å¦‚æœå•Ÿç”¨èª¿è©¦æ¨¡å¼ï¼Œæ·»åŠ èª¿è©¦æ—¥èªŒ
    access_log /usr/local/openresty/nginx/logs/debug.log debug;

    # åŸºæœ¬è¨­å®š
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    client_max_body_size 100M;

    # Gzip å£“ç¸®
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript application/javascript application/xml+rss application/json;

    # å…±äº«è¨˜æ†¶é«”å€åŸŸ
    lua_shared_dict health_checker 10m;
    lua_shared_dict monitor_routing 10m;
    lua_shared_dict node_capacity 1m;

    # ä¸Šæ¸¸ä¼ºæœå™¨é…ç½® - å‹•æ…‹å¤šç¯€é»ï¼ˆç”± OpenResty + Lua æ±ºå®šå¯¦éš›ç¯€é»ï¼‰
    #
    # èªªæ˜ï¼š
    # - upstream å…§åªæ”¾ä¸€å€‹ dummy server
    # - çœŸæ­£è¦é€£ç·šçš„ç¯€é»ç”± access_by_lua é é¸ï¼Œbalancer_by_lua è®€å–é é¸çµæœ
    # - ç¯€é»åˆ—è¡¨èˆ‡ç‹€æ…‹ä¾†æºï¼šè³‡æ–™åº« node tableï¼ˆæˆ–ä¹‹å¾Œæ“´å…… shared_dictï¼‰
    # - æ³¨æ„ï¼šbalancer_by_lua* éšæ®µä¸èƒ½ä½¿ç”¨ socket APIï¼Œæ‰€ä»¥ DB æŸ¥è©¢å¿…é ˆåœ¨ access éšæ®µå®Œæˆ
    upstream uptime_kuma_cluster {
        server 127.0.0.1:1;  # dummy serverï¼Œå¯¦éš›ç›®æ¨™ç”± Lua è¨­å®š

        balancer_by_lua_block {
            local balancer = require "ngx.balancer"
            local router = require "monitor_router"

            -- ä½¿ç”¨åœ¨ access éšæ®µé é¸çš„ç¯€é»ï¼ˆå­˜åœ¨ ngx.ctx ä¸­ï¼‰
            local host, port = router.get_preselected_node()

            if not host or not port then
                ngx.log(ngx.ERR, "No available node IP, cannot route request")
                return ngx.exit(503)
            end

            ngx.log(ngx.DEBUG, "balancer: setting peer to ", host, ":", port)
            
            local ok, err = balancer.set_current_peer(host, port)
            if not ok then
                ngx.log(ngx.ERR, "failed to set upstream peer: ", err)
                return ngx.exit(502)
            end
        }
    }

    # åˆå§‹åŒ–è…³æœ¬
    init_by_lua_block {
        require "resty.core"
        
        -- æª¢æŸ¥èª¿è©¦æ¨¡å¼
        local debug_enabled = os.getenv("EMMY_DEBUG_ENABLED") == "true"
        if debug_enabled then
            ngx.log(ngx.NOTICE, "ğŸ”§ èª¿è©¦æ¨¡å¼å·²å•Ÿç”¨")
        end
        
        -- åˆå§‹åŒ–å¥åº·æª¢æŸ¥å™¨
        local health_check = require "health_check"
        local success = health_check.init()
        if success then
            ngx.log(ngx.INFO, "Health checker initialized successfully")
        else
            ngx.log(ngx.ERR, "Failed to initialize health checker")
        end
    }
    
    # å®šæœŸå¥åº·æª¢æŸ¥
    init_worker_by_lua_block {
        local health_check = require "health_check"
        
        local function start_health_check()
            ngx.log(ngx.INFO, "Starting health check worker")
            health_check.health_check_worker()
        end
        
        local function start_debugger()
            local debug_enabled = os.getenv("EMMY_DEBUG_ENABLED") == "true"
            if debug_enabled then
                ngx.log(ngx.INFO, "ğŸ”§ æº–å‚™å•Ÿå‹•èª¿è©¦å™¨...")
                ngx.timer.at(5, function()
                    health_check.start_debugger()
                end)
            end
        end
        
        ngx.timer.at(10, start_health_check)
        ngx.timer.at(15, start_debugger)
    }

    # ä¸»è¦æœå‹™é…ç½®
    server {
        listen 80;
        server_name _;
        
        # è®Šæ•¸å®šç¾©
        set $target_upstream "";
        set $monitor_id "";
        
        # å®‰å…¨æ¨™é ­
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;

        # -----------------------------------------------------------
        # æ™ºèƒ½è·¯ç”±é‚è¼¯
        # -----------------------------------------------------------

        # 1. ç‰¹å®š Monitor API è«‹æ±‚ - è·¯ç”±åˆ°æ‰€å±¬ç¯€é»
        location ~ ^/api/v1/monitors/(\d+) {
            set $monitor_id $1;
            
            access_by_lua_block { require("middleware").preselect_node() }
            header_filter_by_lua_block { require("middleware").add_routing_headers() }
            
            # å¤šç¯€é»å¢é›†ï¼šäº¤ç”± upstream uptime_kuma_cluster è² è²¬åˆ†æµ
            proxy_pass http://uptime_kuma_cluster;
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Monitor-ID $monitor_id;
        }

        # 2. å‰µå»ºæ–° Monitor - å®¹é‡æ„ŸçŸ¥è·¯ç”±
        location = /api/v1/monitors {
            # åƒ… POST è«‹æ±‚ä½¿ç”¨æ™ºèƒ½è·¯ç”±
            if ($request_method = POST) {
                set $is_post 1;
            }
            
            access_by_lua_block { require("middleware").preselect_node() }
            header_filter_by_lua_block { require("middleware").add_routing_headers() }
            
            # å¤šç¯€é»å¢é›†ï¼šäº¤ç”± upstream uptime_kuma_cluster è² è²¬åˆ†æµ
            proxy_pass http://uptime_kuma_cluster;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }

        # 3. WebSocket è·¯ç”± - å˜—è©¦è¦ªå’Œæ€§
        location /socket.io/ {
            access_by_lua_block { require("middleware").preselect_node() }
            header_filter_by_lua_block { require("middleware").add_routing_headers() }
            
            # å¤šç¯€é»å¢é›†ï¼šäº¤ç”± uptime_kuma_clusterï¼›å¿…è¦æ™‚å¯å†åŠ ä¸Š sticky ç­–ç•¥
            proxy_pass http://uptime_kuma_cluster;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_read_timeout 86400s;
            proxy_send_timeout 86400s;
        }
        
        # -----------------------------------------------------------
        # ç›£æ§èˆ‡ç®¡ç†ç«¯é»
        # -----------------------------------------------------------

        # é›†ç¾¤å¥åº·ç‹€æ…‹
        location /lb/health {
            access_log off;
            content_by_lua_block {
                local router = require "monitor_router"
                local status = router.get_cluster_status()
                ngx.header.content_type = "application/json"
                ngx.say(require('cjson').encode(status))
            }
        }

        # ç¯€é»å®¹é‡ç‹€æ…‹
        location /lb/capacity {
            access_log off;
            content_by_lua_block {
                local router = require "monitor_router"
                local capacity = router.get_node_capacity()
                ngx.header.content_type = "application/json"
                ngx.say(require('cjson').encode(capacity))
            }
        }

        # -----------------------------------------------------------
        # å›ºå®šç¯€é»è·¯ç”±ç®¡ç† | Fixed Node Routing Management
        # -----------------------------------------------------------

        # è¨­å®šå›ºå®šç¯€é» (é€é URL è¨ªå•ï¼Œå›å‚³ HTML)
        # Set fixed node via URL (returns HTML)
        # GET /lb/fixed-node/node1, /lb/fixed-node/node2, etc.
        location ~ ^/lb/fixed-node/(node\d+)$ {
            set $target_node $1;
            
            content_by_lua_block {
                local cjson = require "cjson"
                local router = require "monitor_router"
                local node_id = ngx.var.target_node
                
                -- é©—è­‰ç¯€é»å­˜åœ¨ä¸”åœ¨ç·š | Validate node exists and is online
                local valid, reason = router.validate_fixed_node(node_id)
                
                if not valid then
                    ngx.status = 400
                    ngx.header.content_type = "text/html; charset=utf-8"
                    ngx.say(string.format([[
<!DOCTYPE html>
<html>
<head><title>Setting Failed | è¨­å®šå¤±æ•—</title></head>
<body style="font-family: Arial, sans-serif; padding: 40px; text-align: center;">
    <h1 style="color: #e74c3c;">âŒ Setting Failed | è¨­å®šå¤±æ•—</h1>
    <p>Node <strong>%s</strong> is invalid or offline</p>
    <p>ç¯€é» <strong>%s</strong> ç„¡æ•ˆæˆ–é›¢ç·š</p>
    <p>Reason åŸå› : %s</p>
    <p><a href="/lb/available-nodes">View Available Nodes | æŸ¥çœ‹å¯ç”¨ç¯€é»</a></p>
</body>
</html>
                    ]], node_id, node_id, reason or "unknown"))
                    return
                end
                
                -- è¨­å®š Cookie (7 å¤©æœ‰æ•ˆæœŸ) | Set Cookie (7 days expiry)
                local expires = 604800
                local cookie = string.format(
                    "KUMA_FIXED_NODE=%s; Path=/; Max-Age=%d; HttpOnly",
                    node_id, expires
                )
                ngx.header["Set-Cookie"] = cookie
                
                ngx.header.content_type = "text/html; charset=utf-8"
                ngx.say(string.format([[
<!DOCTYPE html>
<html>
<head><title>Fixed Node Set | å›ºå®šç¯€é»å·²è¨­å®š</title></head>
<body style="font-family: Arial, sans-serif; padding: 40px; text-align: center;">
    <h1 style="color: #27ae60;">âœ… Success | è¨­å®šæˆåŠŸ</h1>
    <p>All requests will be routed to <strong style="color: #3498db; font-size: 1.5em;">%s</strong></p>
    <p>æ‰€æœ‰è«‹æ±‚å°‡å›ºå®šè·¯ç”±åˆ° <strong style="color: #3498db; font-size: 1.5em;">%s</strong></p>
    <p>Expiry æœ‰æ•ˆæœŸ: 7 days å¤©</p>
    <hr style="margin: 30px 0;">
    <p>Clear fixed node æ¸…é™¤å›ºå®šç¯€é»: <a href="/lb/clear-fixed-node">/lb/clear-fixed-node</a></p>
    <p>View status æŸ¥çœ‹ç‹€æ…‹: <a href="/lb/fixed-node-status">/lb/fixed-node-status</a></p>
    <p><a href="/">Back to Home è¿”å›é¦–é </a></p>
</body>
</html>
                ]], node_id, node_id))
            }
        }

        # æ¸…é™¤å›ºå®šç¯€é» (é€é URL è¨ªå•ï¼Œå›å‚³ HTML)
        # Clear fixed node via URL (returns HTML)
        # GET /lb/clear-fixed-node
        location = /lb/clear-fixed-node {
            content_by_lua_block {
                -- æ¸…é™¤ Cookie | Clear Cookie
                local cookie = "KUMA_FIXED_NODE=; Path=/; Max-Age=0; HttpOnly"
                ngx.header["Set-Cookie"] = cookie
                
                ngx.header.content_type = "text/html; charset=utf-8"
                ngx.say([[
<!DOCTYPE html>
<html>
<head><title>Fixed Node Cleared | å›ºå®šç¯€é»å·²æ¸…é™¤</title></head>
<body style="font-family: Arial, sans-serif; padding: 40px; text-align: center;">
    <h1 style="color: #27ae60;">âœ… Cleared | å·²æ¸…é™¤</h1>
    <p>Fixed node Cookie has been cleared</p>
    <p>å›ºå®šç¯€é» Cookie å·²æ¸…é™¤</p>
    <p>Requests will use <strong>normal load balancing</strong></p>
    <p>å¾ŒçºŒè«‹æ±‚å°‡æ¢å¾©<strong>æ­£å¸¸è² è¼‰å‡è¡¡</strong></p>
    <hr style="margin: 30px 0;">
    <p>Set fixed node again é‡æ–°è¨­å®šå›ºå®šç¯€é»:</p>
    <p>
        <a href="/lb/fixed-node/node1">node1</a> | 
        <a href="/lb/fixed-node/node2">node2</a> | 
        <a href="/lb/fixed-node/node3">node3</a>
    </p>
    <p><a href="/">Back to Home è¿”å›é¦–é </a></p>
</body>
</html>
                ]])
            }
        }

        # è¨­å®šå›ºå®šç¯€é» (JSON API)
        # Set fixed node (JSON API)
        # POST /lb/set-fixed-node
        location = /lb/set-fixed-node {
            content_by_lua_block {
                local cjson = require "cjson"
                
                -- åªå…è¨± POST | Only allow POST
                if ngx.req.get_method() ~= "POST" then
                    ngx.status = 405
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error":"Method not allowed"}')
                    return
                end
                
                -- è®€å– body | Read body
                ngx.req.read_body()
                local body = ngx.req.get_body_data()
                
                if not body then
                    ngx.status = 400
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error":"Missing request body"}')
                    return
                end
                
                local ok, data = pcall(cjson.decode, body)
                if not ok or not data.node then
                    ngx.status = 400
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error":"Invalid JSON or missing node parameter"}')
                    return
                end
                
                local node_id = data.node
                local expires = data.expires or 604800  -- é è¨­ 7 å¤© | Default 7 days
                
                -- é©—è­‰ç¯€é»æ ¼å¼ | Validate node format
                if not string.match(node_id, "^node%d+$") then
                    ngx.status = 400
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error":"Invalid node format. Use node1, node2, etc."}')
                    return
                end
                
                -- é©—è­‰ç¯€é»å­˜åœ¨ä¸”åœ¨ç·š | Validate node exists and is online
                local router = require "monitor_router"
                local valid, reason = router.validate_fixed_node(node_id)
                
                if not valid then
                    ngx.status = 400
                    ngx.header.content_type = "application/json"
                    ngx.say(cjson.encode({error = "Node validation failed", reason = reason}))
                    return
                end
                
                -- è¨­å®š Cookie | Set Cookie
                local cookie = string.format(
                    "KUMA_FIXED_NODE=%s; Path=/; Max-Age=%d; HttpOnly",
                    node_id, expires
                )
                ngx.header["Set-Cookie"] = cookie
                
                ngx.header.content_type = "application/json"
                ngx.say(cjson.encode({
                    success = true,
                    node = node_id,
                    expires_in_seconds = expires,
                    message = "Fixed node cookie set successfully"
                }))
            }
        }

        # æŸ¥çœ‹ç•¶å‰å›ºå®šç¯€é»ç‹€æ…‹
        # View current fixed node status
        # GET /lb/fixed-node-status
        location = /lb/fixed-node-status {
            content_by_lua_block {
                local cjson = require "cjson"
                local router = require "monitor_router"
                
                local fixed_node = ngx.var.cookie_KUMA_FIXED_NODE
                local status = {
                    has_fixed_node = false,
                    current_node = cjson.null,
                    is_valid = false,
                    cluster_status = router.get_cluster_status()
                }
                
                if fixed_node and fixed_node ~= "" then
                    status.has_fixed_node = true
                    status.current_node = fixed_node
                    
                    local valid, reason = router.validate_fixed_node(fixed_node)
                    status.is_valid = valid
                    if not valid then
                        status.invalid_reason = reason
                    end
                end
                
                ngx.header.content_type = "application/json"
                ngx.say(cjson.encode(status))
            }
        }

        # åˆ—å‡ºæ‰€æœ‰å¯ç”¨ç¯€é»
        # List all available nodes
        # GET /lb/available-nodes
        location = /lb/available-nodes {
            content_by_lua_block {
                local cjson = require "cjson"
                local router = require "monitor_router"
                
                local status = router.get_cluster_status()
                local available_nodes = {}
                
                if status.nodes then
                    for _, node in ipairs(status.nodes) do
                        if node.status == "online" then
                            table.insert(available_nodes, {
                                node_id = node.node_id,
                                status = node.status,
                                monitor_count = node.monitor_count,
                                set_url = "/lb/fixed-node/" .. node.node_id
                            })
                        end
                    end
                end
                
                ngx.header.content_type = "application/json"
                ngx.say(cjson.encode({
                    available_nodes = available_nodes,
                    total_count = #available_nodes,
                    clear_url = "/lb/clear-fixed-node"
                }))
            }
        }

        # ä¸‹æ–¹ä¿ç•™åŸæœ‰çš„å¥åº·æª¢æŸ¥ API ...
        
        location /health {
            access_log off;
            return 200 '{"status":"healthy","timestamp":"$time_iso8601","service":"nginx-openresty"}';
            add_header Content-Type application/json;
        }

        location /api/health-status {
            content_by_lua_block {
                local health_check = require "health_check"
                local stats = health_check.get_statistics()
                ngx.header.content_type = "application/json"
                ngx.say(require('cjson').encode(stats))
            }
        }

        location /api/trigger-health-check {
            content_by_lua_block {
                local health_check = require "health_check"
                local success = health_check.run_health_check()
                
                if success then
                    ngx.status = 200
                    ngx.say('{"status":"success","message":"Health check triggered successfully"}')
                else
                    ngx.status = 500
                    ngx.say('{"status":"error","message":"Health check failed"}')
                end
                ngx.header.content_type = "application/json"
            }
        }

        location /api/debug-config {
            content_by_lua_block {
                local health_check = require "health_check"
                local debug_config = health_check.get_debug_config()
                ngx.header.content_type = "application/json"
                ngx.say(require('cjson').encode(debug_config))
            }
        }
        
        location /api/debug-logs {
            content_by_lua_block {
                -- ç°¡åŒ–è™•ç†ï¼Œç›´æ¥è®€å–
                local file = io.open("/usr/local/openresty/nginx/logs/debug.log", "r")
                if file then
                    local content = file:read("*all")
                    file:close()
                    ngx.say(content)
                else
                    ngx.say("No logs")
                end
            }
        }

        # -----------------------------------------------------------
        # é»˜èªè·¯ç”±
        # -----------------------------------------------------------

        # éœæ…‹æ–‡ä»¶
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
            
            access_by_lua_block { require("middleware").preselect_node() }
            header_filter_by_lua_block { require("middleware").add_routing_headers() }
            
            proxy_pass http://uptime_kuma_cluster;
        }

        # æ‰€æœ‰å…¶ä»– API å’Œè«‹æ±‚
        location / {
            access_by_lua_block { require("middleware").preselect_node() }
            header_filter_by_lua_block { require("middleware").add_routing_headers() }
            
            proxy_pass http://uptime_kuma_cluster;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
        }
    }
}
