user root;
worker_processes auto;
worker_rlimit_nofile 65535;
error_log /usr/local/openresty/nginx/logs/error.log info;
pid /var/run/nginx.pid;

# å¥åº·æª¢æŸ¥å°ˆç”¨æ—¥èªŒï¼ˆè¨˜éŒ„ info ä»¥ä¸Šï¼‰
error_log /usr/local/openresty/nginx/logs/health-check.log info;


events {
    use epoll;
    worker_connections 65535;
    multi_accept on;
}

http {
    include /usr/local/openresty/nginx/conf/mime.types;
    default_type application/octet-stream;

    # Docker å…§å»º DNS è§£æå™¨
    resolver 127.0.0.11 ipv6=off valid=30s;
    resolver_timeout 5s;

    # Map for Connection header handling
    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }

    # æ—¥èªŒæ ¼å¼
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for" '
                    'upstream: $upstream_addr routed_to: $upstream_http_x_routed_node';

    # èª¿è©¦æ—¥èªŒæ ¼å¼
    log_format debug '$remote_addr - $remote_user [$time_local] "$request" '
                     '$status $body_bytes_sent "$http_referer" '
                     '"$http_user_agent" "$http_x_forwarded_for" '
                     'debug_info: "$http_x_debug_info"';

    access_log /usr/local/openresty/nginx/logs/access.log main;
    
    # å¦‚æœå•Ÿç”¨èª¿è©¦æ¨¡å¼ï¼Œæ·»åŠ èª¿è©¦æ—¥èªŒ
    access_log /usr/local/openresty/nginx/logs/debug.log debug;

    # åŸºæœ¬è¨­å®š
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    client_max_body_size 100M;

    # Gzip å£“ç¸®
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript application/javascript application/xml+rss application/json;

    # å…±äº«è¨˜æ†¶é«”å€åŸŸ
    lua_shared_dict health_checker 10m;
    lua_shared_dict monitor_routing 10m;
    lua_shared_dict node_capacity 1m;

    # ä¸Šæ¸¸ä¼ºæœå™¨é…ç½® - å‹•æ…‹å¤šç¯€é»ï¼ˆç”± OpenResty + Lua æ±ºå®šå¯¦éš›ç¯€é»ï¼‰
    #
    # èªªæ˜ï¼š
    # - upstream å…§åªæ”¾ä¸€å€‹ dummy server
    # - çœŸæ­£è¦é€£ç·šçš„ç¯€é»ç”± balancer_by_lua_block å‘¼å« monitor_router.pick_node_for_request å‹•æ…‹æ±ºå®š
    # - ç¯€é»åˆ—è¡¨èˆ‡ç‹€æ…‹ä¾†æºï¼šè³‡æ–™åº« node tableï¼ˆæˆ–ä¹‹å¾Œæ“´å…… shared_dictï¼‰
    upstream uptime_kuma_cluster {
        server 127.0.0.1:1;  # dummy serverï¼Œå¯¦éš›ç›®æ¨™ç”± Lua è¨­å®š

        balancer_by_lua_block {
            local balancer = require "ngx.balancer"
            local router = require "monitor_router"

            local host, port = router.pick_node_for_request()

            if not host then
                ngx.log(ngx.ERR, "No available node from monitor_router, fallback to uptime-kuma-node1")
                host = "uptime-kuma-node1"
                port = 3001
            end

            local ok, err = balancer.set_current_peer(host, port)
            if not ok then
                ngx.log(ngx.ERR, "failed to set upstream peer: ", err)
                return ngx.exit(502)
            end
        }
    }

    # åˆå§‹åŒ–è…³æœ¬
    init_by_lua_block {
        require "resty.core"
        
        -- æª¢æŸ¥èª¿è©¦æ¨¡å¼
        local debug_enabled = os.getenv("EMMY_DEBUG_ENABLED") == "true"
        if debug_enabled then
            ngx.log(ngx.NOTICE, "ğŸ”§ èª¿è©¦æ¨¡å¼å·²å•Ÿç”¨")
        end
        
        -- åˆå§‹åŒ–å¥åº·æª¢æŸ¥å™¨
        local health_check = require "health_check"
        local success = health_check.init()
        if success then
            ngx.log(ngx.INFO, "Health checker initialized successfully")
        else
            ngx.log(ngx.ERR, "Failed to initialize health checker")
        end
    }
    
    # å®šæœŸå¥åº·æª¢æŸ¥
    init_worker_by_lua_block {
        local health_check = require "health_check"
        
        local function start_health_check()
            ngx.log(ngx.INFO, "Starting health check worker")
            health_check.health_check_worker()
        end
        
        local function start_debugger()
            local debug_enabled = os.getenv("EMMY_DEBUG_ENABLED") == "true"
            if debug_enabled then
                ngx.log(ngx.INFO, "ğŸ”§ æº–å‚™å•Ÿå‹•èª¿è©¦å™¨...")
                ngx.timer.at(5, function()
                    health_check.start_debugger()
                end)
            end
        end
        
        ngx.timer.at(10, start_health_check)
        ngx.timer.at(15, start_debugger)
    }

    # ä¸»è¦æœå‹™é…ç½®
    server {
        listen 80;
        server_name _;
        
        # è®Šæ•¸å®šç¾©
        set $target_upstream "";
        set $monitor_id "";
        
        # å®‰å…¨æ¨™é ­
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;

        # -----------------------------------------------------------
        # æ™ºèƒ½è·¯ç”±é‚è¼¯
        # -----------------------------------------------------------

        # 1. ç‰¹å®š Monitor API è«‹æ±‚ - è·¯ç”±åˆ°æ‰€å±¬ç¯€é»
        location ~ ^/api/v1/monitors/(\d+) {
            set $monitor_id $1;
            
            # å¤šç¯€é»å¢é›†ï¼šäº¤ç”± upstream uptime_kuma_cluster è² è²¬åˆ†æµ
            proxy_pass http://uptime_kuma_cluster;
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Monitor-ID $monitor_id;
        }

        # 2. å‰µå»ºæ–° Monitor - å®¹é‡æ„ŸçŸ¥è·¯ç”±
        location = /api/v1/monitors {
            # åƒ… POST è«‹æ±‚ä½¿ç”¨æ™ºèƒ½è·¯ç”±
            if ($request_method = POST) {
                set $is_post 1;
            }
            
            # å¤šç¯€é»å¢é›†ï¼šäº¤ç”± upstream uptime_kuma_cluster è² è²¬åˆ†æµ
            proxy_pass http://uptime_kuma_cluster;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }

        # 3. WebSocket è·¯ç”± - å˜—è©¦è¦ªå’Œæ€§
        location /socket.io/ {
            # å¤šç¯€é»å¢é›†ï¼šäº¤ç”± uptime_kuma_clusterï¼›å¿…è¦æ™‚å¯å†åŠ ä¸Š sticky ç­–ç•¥
            proxy_pass http://uptime_kuma_cluster;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_read_timeout 86400s;
            proxy_send_timeout 86400s;
        }
        
        # -----------------------------------------------------------
        # ç›£æ§èˆ‡ç®¡ç†ç«¯é»
        # -----------------------------------------------------------

        # é›†ç¾¤å¥åº·ç‹€æ…‹
        location /lb/health {
            access_log off;
            content_by_lua_block {
                local router = require "monitor_router"
                local status = router.get_cluster_status()
                ngx.header.content_type = "application/json"
                ngx.say(require('cjson').encode(status))
            }
        }

        # ç¯€é»å®¹é‡ç‹€æ…‹
        location /lb/capacity {
            access_log off;
            content_by_lua_block {
                local router = require "monitor_router"
                local capacity = router.get_node_capacity()
                ngx.header.content_type = "application/json"
                ngx.say(require('cjson').encode(capacity))
            }
        }

        # ä¸‹æ–¹ä¿ç•™åŸæœ‰çš„å¥åº·æª¢æŸ¥ API ...
        
        location /health {
            access_log off;
            return 200 '{"status":"healthy","timestamp":"$time_iso8601","service":"nginx-openresty"}';
            add_header Content-Type application/json;
        }

        location /api/health-status {
            content_by_lua_block {
                local health_check = require "health_check"
                local stats = health_check.get_statistics()
                ngx.header.content_type = "application/json"
                ngx.say(require('cjson').encode(stats))
            }
        }

        location /api/trigger-health-check {
            content_by_lua_block {
                local health_check = require "health_check"
                local success = health_check.run_health_check()
                
                if success then
                    ngx.status = 200
                    ngx.say('{"status":"success","message":"Health check triggered successfully"}')
                else
                    ngx.status = 500
                    ngx.say('{"status":"error","message":"Health check failed"}')
                end
                ngx.header.content_type = "application/json"
            }
        }

        location /api/debug-config {
            content_by_lua_block {
                local health_check = require "health_check"
                local debug_config = health_check.get_debug_config()
                ngx.header.content_type = "application/json"
                ngx.say(require('cjson').encode(debug_config))
            }
        }
        
        location /api/debug-logs {
            content_by_lua_block {
                -- ç°¡åŒ–è™•ç†ï¼Œç›´æ¥è®€å–
                local file = io.open("/usr/local/openresty/nginx/logs/debug.log", "r")
                if file then
                    local content = file:read("*all")
                    file:close()
                    ngx.say(content)
                else
                    ngx.say("No logs")
                end
            }
        }

        # -----------------------------------------------------------
        # é»˜èªè·¯ç”±
        # -----------------------------------------------------------

        # éœæ…‹æ–‡ä»¶
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
            proxy_pass http://uptime_kuma_cluster;
        }

        # æ‰€æœ‰å…¶ä»– API å’Œè«‹æ±‚
        location / {
            proxy_pass http://uptime_kuma_cluster;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
        }
    }
}
